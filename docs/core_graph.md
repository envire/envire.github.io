---
id: core_graph
title: Graph
subtitle:
---

## Graph
The envire graph is the backbone of the whole library. It stores arbitrary data
and time & space transformations between the data.

### Structure
The graph itself is implemented as inheritance chain. Each class in the chain
adds some of the functionality.

![graphuml](https://raw.githubusercontent.com/envire/envire.github.io/master/images/envire_core_graph_inherit.png)


``envire::core::Graph<E,V>`` is the root class the graph structure. It extends
a ``boost::labeled_graph``. The template parameters ``E`` and ``V`` are edge and
vertex properties, i.e. they are used to add additional data to the edges and
vertices of the graph. The ``Graph`` provides basic features like frame ids, support
for events and tree views.

Edge properties need to implement the ``envire::core::EdgePropertyConcept`` while
vertex properties need to implement ``envire::core::FramePropertyConcept``.
The concepts are checked at compile time using the Boost Concept Checking Library.

The ``TransformGraph<V>`` extends ``Graph<Transformation, V>``. It adds functionality
to calculate and set transformations between frames.

The ``EnvireGraph`` extends ``TransformGraph<Frame>``. It adds functionality to
add, remove and manipulate items.



#### Frames
Frames are vertices in the graph structure. Each frame is identified by an identifier
(string). The identifier has to be unique.
Each frame carries a set of Items indexed by type.

#### Transformations
Transformations (envire::core::Transformation) are edges in the graph structure.
Transformations describe the spatial and temporal displacement between frames.

#### Items
The data elements that are stored in the nodes of the graph are called Items.
Every item must inherit from `envire::core::ItemBase`. `getTypeInfo()`
and `getEmbeddedTypeInfo()` need to be overridden to provide correct type information
about the item. `getTypeInfo()` should return the `type_info` of the item itself
while `getEmbeddedTypeInfo()` should return the type of the encapsulated data (i.e.
the type of the data that is returned in `getRawData()`).

A template (`envire::core::Item<T>`) that inherits from `ItemBase` and carries
arbitrary data is provided for convenience. Thus manually inheriting from `ItemBase`
should not be necessary.


#### Creating new Items
New item types should always be defined using the envire plugin mechanism because
the plugin macros add metadata that is needed for corect serialization and
visualization.

**Minimal Example**
*Header File:*

```cpp
namespace envire { namespace myNamespace
{
  struct MyInternalType{};

  struct MyItem : public envire::core::Item<MyInternalType>
  {
    ENVIRE_PLUGIN_HEADER(MyItem)
    virtual const std::type_info* getTypeInfo() const override
    {
      return &typeid(envire::myNamespace::MyItem);
    }
  };
}}


namespace boost { namespace serialization
{
  template<class Archive>
  void serialize(Archive & ar, ::envire::myNamespace::MyInternalType & data, const unsigned int version)
  {
    //serialize
  }
}}
```

*Cpp File:*

```cpp
ENVIRE_REGISTER_PLUGIN(envire::pcl::PointCloud, pcl::PCLPointCloud2)
```

#### Tree Views
``TreeViews`` are lightweight structures that *view* a portion of the graph as tree.
Views are generated by bfs-visiting the graph starting at a given frame.
All frames that are reachable from that frame will be part of the view. The structure
does not contain any loops (it is a tree, not a graph). Edges that would create
loops in the tree are called cross-edges and are stored in a special list inside
the ``TreeView``.

A ``TreeView`` can either be static or dynamic. A static view is a snapshot of the
graph at the time it was taken. I.e. it will not update or change. If the graph changes,
parts of the tree might become invalid.

A dynamic ``TreeView`` is updated automatically whenever the underlying graph changes.
The view provides signals that will be emitted when that happens. Dynamic views
significantly increase the computational cost of all manipulative graph operations.
Especially the removal of edges might be costly.

A ``TreeView`` contains pointers to the actual data, thus if the underlying graph
is destroyed, the view becomes invalid.
