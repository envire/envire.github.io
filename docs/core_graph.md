---
id: core_graph
title: Graph
subtitle:
---

## Graph
The envire graph is the backbone of the whole library. It stores arbitrary data
and time & space transformations between the data.

### Structure


#### Tree Views
``TreeViews`` are lightweight structures that *view* a portion of the graph as tree.
Views are generated by bfs visiting the graph starting at a certain frame.
All frames that are reachable from that frame will be part of the view. The structure
does not contain any loops (it is a tree, not a graph). Edges that would create
loops in the tree are called cross-edges and are stored in a special list inside
the ``TreeView``.

A ``TreeView`` can either be static or dynamic. A static view is a snapshot of the
graph at the time it was taken. I.e. it will not update or change. If the graph changes,
parts of the tree might become invalid. A dynamic ``TreeView`` is updated
automatically whenever the underlying graph changes. The view provides signals that
will be emitted whenever that happens. Dynamic views significantly increase the
computational cost of all manipulative graph operations.



#### Frames
Frames are vertices in the graph structure. Each frame is identified by an identifier
(string). The identifier has to be unique.
Each frame carries a set of Items indexed by type.

#### Transformations
Transformations (envire::core::Transformation) are edges in the graph structure.
Transformations describe the spatial and temporal displacement between frames.



#### Items
The data elements that are stored in the nodes of the graph are called Items.
Every item must inherit from `envire::core::ItemBase`. `getTypeInfo()`
and `getEmbeddedTypeInfo()` need to be overridden to provide correct type information
about the item. `getTypeInfo()` should return the `type_info` of the item itself
while `getEmbeddedTypeInfo()` should return the type of the encapsulated data (i.e.
the type of the data that is returned in `getRawData()`).

A template (`envire::core::Item<T>`) that inherits from `ItemBase` and carries
arbitrary data is provided for convenience. Thus manually inheriting from `ItemBase`
should not be necessary.


#### Creating new Items
New item types should always be defined using the envire plugin mechanism because
the plugin macros add metadata that is needed for corect serialization and
visualization.
##### Minimal example
**Header File:**
```c++
namespace envire { namespace myNamespace
{
  struct MyInternalType{};

  struct MyItem : public envire::core::Item<MyInternalType>
  {
    ENVIRE_PLUGIN_HEADER(MyItem)
    virtual const std::type_info* getTypeInfo() const override
    {
      return &typeid(envire::myNamespace::MyItem);
    }
  };
}}


namespace boost { namespace serialization
{
  template<class Archive>
  void serialize(Archive & ar, ::envire::myNamespace::MyInternalType & data, const unsigned int version)
  {
    //serialize
  }
}}
```
**Cpp File:**
```c++
ENVIRE_REGISTER_PLUGIN(envire::pcl::PointCloud, pcl::PCLPointCloud2)
```


### Edges
